#include <iostream>
#include "togasat.hpp"
using namespace std;
int code[4]; // to store a hidden code
int colormap[9] = {0};
int breakcode[4]; // used by codebreaker to store it's guesses
int B = 0;
int W = 0;
int totalvar = 32;
bool stop = false;
char ch[] = {'R', 'B', 'G', 'Y', 'O', 'P', 'W', 'K'}; // mapping 1-8 colors to character
vector<vector<int>> clauses;                          // to store all the clauses incrementelly based on feedback
struct Color
{
    int code, freq;
};

//Generate  random numbers
void randoms(int a[], int lower, int upper, int count)
{
    srand(time(0));
    for (int i = 0; i < count; i++)
    {
        int num = (rand() % (upper - lower + 1)) + lower;
        a[i] = num;
    }
}

void addwhite(vector<vector<int>> &v, vector<int> &a, vector<int> &b, int idx, int white)
{
    if (white == 0)
    {
        v.push_back(a);
        return;
    }
    if (idx >= b.size())
    {
        return;
    }
    a.push_back(b[idx]);
    addwhite(v, a, b, idx + 1, white - 1);
    a.pop_back();
    addwhite(v, a, b, idx + 1, white);
}

//This function generate all possible compinations of indexes for a recieved feedback
void generate(vector<vector<int>> &v, vector<int> &a, vector<int> &b, int index, int black, int blank)
{
    if (black == 0 && blank == 0)
    {
        vector<int> temp;
        vector<int> tt;
        for (int i = 0; i < 4; i++)
        {
            if (b[i] == 0)
            {
                temp.push_back(a[i]);
            }
            if (b[i] == -1 || b[i] == 1)
            {
                tt.push_back(a[i]);
            }
        }

        for (int i = 0; i < 4; i++)
        {
            if (b[i] == 1)
            {
                temp.push_back(a[i]);
            }
        }

        addwhite(v, temp, tt, 0, W);
        return;
    }
    if (index >= a.size())
    {
        return;
    }
    b[index] = 0;
    generate(v, a, b, index + 1, black - 1, blank);
    b[index] = 1;
    generate(v, a, b, index + 1, black, blank - 1);
    b[index] = -1;
    generate(v, a, b, index + 1, black, blank);
}
//To invoke a SAT solver
void solve(vector<vector<int>> v, togasat::Solver &solver)
{
    for (int i = 0; i < v.size(); i++)
    {
        if (v[i].size() == 0)
        {
            continue;
        }
        solver.addClause(v[i]);
    }

    bool status = solver.solve();
}

//It generates a hidden code - duplicates are allowed
void codemaker()
{
    randoms(code, 1, 8, 4);
    for (int i = 0; i < 4; i++)
    {
        colormap[code[i]]++;
        cout << ch[code[i] - 1] << " ";
    }
    cout << endl;
}

//Check colors generated by codebreaker with the hidden code and it provides feedback
void codecheker(int a[])
{
    B = 0;
    W = 0;
    int tempmap[9] = {0};
    for (int i = 0; i < 4; i++)
    {
        cout << ch[a[i] - 1] << " ";
        if (code[i] == a[i])
            B++;
        tempmap[a[i]]++;
    }

    for (int i = 0; i <= 8; i++)
    {
        W += min(colormap[i], tempmap[i]);
    }

    W -= B;

    cout << " W : " << W << " B: " << B << endl;
}

/*This function set up rules for the game.
It allows exactly 4 variables to be true from 1 to 32 such that no two different colors are chosen for the same index.
*/
void initialize()
{
    togasat::Solver solver;
    vector<int> clause;
    int k = 1;
    for (int i = 1; i <= 4; i++)
    {
        for (int j = k; j <= k + 7; j++)
        {
            clause.push_back(j);
        }
        clauses.push_back(clause);
        clause.clear();

        for (int j = k; j <= k + 7; j++)
        {

            for (int t = k; t <= k + 7; t++)
            {
                if (t == j)
                    continue;
                else
                {
                    clause.push_back(-j);
                    clause.push_back(-t);
                    clauses.push_back(clause);
                    clause.clear();
                }
            }
        }

        k = k + 8;
    }

    solve(clauses, solver);
}

/*It will generate a color array
Based on feedback received,it will add new clauses.
Thus, function will be called repeateadly untill it cracks the hidden code.
*/
void codebreaker()
{
    vector<int> clause;
    togasat::Solver solver;

    int j = 0;
    vector<int> freq(9, 0);
    breakcode[0] = breakcode[1] = breakcode[2] = breakcode[3] = 0;

    solve(clauses, solver);

    for (int i = 0; i < 32; i++)
    {
        if (solver.assigns[i] == 0)
        {

            breakcode[j] = (i + 1) % 8;
            if (breakcode[j] == 0)
                breakcode[j] = 8;

            freq[breakcode[j]]++;

            j++;
            if (j == 4)
                break;
        }
    }
    bool debug = false;

    codecheker(breakcode);

    if (B == 4)
    {
        stop = true;
        return;
    }

    for (int i = 0; i < 4; i++)
    {
        breakcode[i] = (i * 8) + breakcode[i];
        clause.push_back(-breakcode[i]);
    }
    clauses.push_back(clause);
    clause.clear();
    int variable = totalvar;
    vector<int> clause1;
    vector<int> clause2;
    vector<int> clause3;

    //for blank
    for (int i = 0; i < 4; i++)
    {
        variable++;
        clause1.push_back(variable);
        for (int j = 1; j <= 8; j++)
        {
            if (freq[j] == 0)
                continue;

            clause.push_back(-variable);
            clause.push_back(-(i * 8 + j));
            clauses.push_back(clause);
            clause.clear();
            clause1.push_back((i * 8 + j));
        }
        clauses.push_back(clause1);
        clause1.clear();
    }

    int blank = 4 - (B + W);
    // blank = 0;

    if (B == 0)
    {
        for (int j = 1; j < 4; j++)
        {
            clause.push_back(-breakcode[j]);
            clauses.push_back(clause);
            clause.clear();
        }
    }
    if (blank == 0)
    {
        for (int j = 0; j < 4; j++)
        {
            for (int k = 0; k < 4; k++)
            {
                int p = breakcode[k] % 8;
                if (p == 0)
                    p = 8;
                p = ((j * 8) + p);
                clause.push_back(p);
            }
            clauses.push_back(clause);
            clause.clear();
        }
    }

    vector<vector<int>> permute;
    vector<int> a(4);
    vector<int> b(4, -1);
    for (int i = 0; i < 4; i++)
        a[i] = i + 1;
    generate(permute, a, b, 0, B, blank);

    for (int i = 0; i < permute.size(); i++)
    {
        int fixedvar = -1;
        bool flag = false;
        vector<int> ar(5, 0);

        if (B > 0)
        {
            for (int k = 0; k < B; k++)
            {
                ar[permute[i][k]] = -1;
            }
            variable++;
            fixedvar = variable;
            clause1.push_back(fixedvar);
            for (int j = 0; j < B; j++)
            {

                clause.push_back(-fixedvar);
                int disp = breakcode[permute[i][j] - 1];
                clause.push_back(disp);
                clauses.push_back(clause);
                clause.clear();
                clause1.push_back(-disp);
            }
            for (int j = 1; j <= 4; j++)
            {
                if (ar[j] == 0)
                {
                    clause.push_back(-fixedvar);
                    clause.push_back(-breakcode[j - 1]);
                    clauses.push_back(clause);
                    clause.clear();
                    clause1.push_back(breakcode[j - 1]);
                }
            }
            flag = true;
        }
        if (blank > 0)
        {
            for (int k = B; k < B + blank; k++)
            {
                ar[permute[i][k]] = -2;
            }
            if (!flag)
            {
                variable++;
                fixedvar = variable;
                clause1.push_back(fixedvar);
            }
            for (int j = B; j < B + blank; j++)
            {
                clause.push_back(-fixedvar);
                int disp = totalvar + permute[i][j];
                clause.push_back(disp);
                clauses.push_back(clause);
                clause.clear();
                clause1.push_back(-disp);
            }
            for (int j = 1; j <= 4; j++)
            {
                if (ar[j] == 0)
                {
                    clause.push_back(-fixedvar);
                    int disp = totalvar + j;
                    clause.push_back(-disp);
                    clauses.push_back(clause);
                    clause.clear();
                    clause1.push_back(disp);
                }
            }

            flag = true;
        }
        if (W > 0)
        {
            if (!flag)
            {
                variable++;
                fixedvar = variable;
                clause1.push_back(fixedvar);
            }

            for (int j = B + blank; j < B + blank + W; j++)
            {
                variable++;
                int col = breakcode[permute[i][j] - 1];
                int p = col % 8;
                if (p == 0)
                    p = 8;
                clause3.push_back(-variable);
                for (int k = 1; k <= 4; k++)
                {
                    if (ar[k] < 0 || k == permute[i][j])
                    {
                        continue;
                    }

                    else
                    {
                        int f = (k - 1) * 8 + p;
                        clause.push_back(variable);
                        clause.push_back(-f);
                        clauses.push_back(clause);
                        clause.clear();
                        clause3.push_back(f);
                    }
                }

                clauses.push_back(clause3);
                clause3.clear();

                clause.push_back(-fixedvar);
                clause.push_back(variable);
                clauses.push_back(clause);
                clause.clear();
                clause1.push_back(-variable);
            }

            flag = true;
        }

        if (flag)
        {
            clauses.push_back(clause1);
            clause1.clear();
            clause2.push_back(fixedvar);
        }
    }
    if (clause2.size() > 0)
    {
        clauses.push_back(clause2);
        clause2.clear();
    }

    totalvar = variable;
}

int main()
{

    initialize();
    codemaker();
    while (true)
    {
        codebreaker();
        if (stop)
            break;
    }
    return 0;
}